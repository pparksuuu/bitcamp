//배열 - 배열 레퍼런스와 배열 인스턴스의 관계
      //부제: 가비지와 가비지 컬렉터
package step02;

public class Exam09_4 {
  public static void main(String[] args) {
    int[] arr1;
    arr1 = new int[]{100, 200, 300};

    System.out.println(arr1[0]);
    System.out.println(arr1[1]);
    System.out.println(arr1[2]);
    
    //새로운 int 배열을 확보하여 arr1 레퍼런스에 그 주소를 저장한다
    arr1 = new int[]{10, 20, 30, 40, 50};
    System.out.println(arr1[0]);
    System.out.println(arr1[1]);
    System.out.println(arr1[2]);
  }
}

/**
 //garbage는 개발자가 임의로 제거할 수 없다.(C와 다른 점.)
 
Garbage
 - 주소를 잃어버려 사용할 수 없는 메모리(인스턴스)
 - JVM을 종료하면 어차피 OS에게 사용한 메모리를 반납해야 하기 때문에 
 자동으로 해제된다.
 - 그러나 JVM이 실행하는 중에 개발자가 임의로 해제 X
 - 오직 가비지 컬렉터(garbage collector)만이 가비지를 해제할 수 있다.

Garbage collector
 - 인스턴스의 주소를 알고 있는 변수가 없을 경우 
   그 인스턴스는 가비지로 간주된다.
 - 가비지 메모리를 재사용할 수 있도록 해제시키는 방법
   => 개발자가 임의로 해제 불가능
   => 가비지 컬렉터가 실행되어야만 해제시킬 수 있다.

가비지 컬렉터의 실행
   => 다음의 경우에 가비지 컬렉터가 실행되어 가비지들이 해제된다.
      1) 메모리가 부족할 경우
        -OS에게 메모리를 요청하기 전에 먼저 가비지를 청소한 다음에 요청할 지 말지 결정
      2) CPU가 한가할 때
        - 24시간, 365일 내내 멈추없이 JVM이 실행될 경우, 
          CPU가 한가한 시간에 가비지를 청소할 수 있다.
        - 정확히 언제인지 시간을 지정하거나 예측할 수는 없다.
      3) 개발자가 가비지 컬렉터를 실행하라고 명령을 내릴 때
        - 명령을 내린다고 즉시 실행되는 것은 아니다
        - 빠른 시일내에 가비지를 실행하라고 JVM에 예약.
결론!
 - 가비지는 가비지 컬렉터가 자기 나름의 조건에 따라 실행할 것이니,
   개발자는 신경쓰지 말라 !
 - 만약 메모리를 개발자가 마음대로 조작하고 싶으면,
   C/C++로 프로그래밍하라!
 - 가비지 컬렉터라는 개념을 등장시킨 이유는,
   C/C++개발자들이     
*/

